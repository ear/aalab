/**
 *  Esercizi per il Laboratorio di Applicazioni dell'Algebra, 18/12/12
 */


/**
 * 1. Scrivere una funzione kesava(n,q) che riceve q ed n coprimi e calcola
 * il numero dei fattori irriducibili di x^n - 1 in F_q[x], utilizzando
 * il Lemma di Burnside.
 */

kesava(n, q) =
{
    /* If a group G acts on a set X we can partition X into orbits
     *
     *     χ(g) = { a in X | ga = a }
     *
     * If G is finite and N is the number of orbits then Burnside's lemma says
     *
     *     N = 1/|G| sum_{g in G} χ(g)
     *
     * Let H_{n,q} be the cyclic subgroup generated by q in (Z_n)^*, then
     * the orbit of the action of h in H_{n,q} on Z_n is
     *
     *     χ(h) = { a in Z_n | ha = a (mod n) }
     *
     * thus its cardinality is
     *
     *    |χ(h)| = |{ solutions a of: (h-1)a = 0 (mod n) }| = GCD(h-1,n)
     *
     */

    my( i = 1,
        h,
        N = n \\ corresponding to i=0 (mod n)
    );

    while( (q^i - 1) % n ,
        h = q^i;
        N += gcd( h-1, n );
        i++;
    );

    N /= i;

    return( N );
}
addhelp(kesava, "kesava(n,q): number of irreducible factors of x^n - 1 over F_q[x] for coprime n, q.");


/**
 * Some tests
 */

kesava_table(p, max_n=30, max_e=10) =
{
    matrix(max_e, max_n, i, j, if( gcd(j, p^i) == 1, kesava( j, p^i ) ));
}
addhelp(kesava_table, "kesava_table(p,max_n=30,max_e=10): the number of irreducible factors of the n-th cyclotomic polynomial (1 ≤ n ≤ max_n, rows) over F_(p^e)[x] (1 ≤ e ≤ max_e, columns).")

numirrpol(n, q) =
{
    return(
        vecsum( apply( ( (d) -> moebius(n/d) * q^d ), divisors(n) ) ) / n
    );
}
addhelp(numirrpol, "numirrpol(n,q): number of monic irreducible polynomials of degree n over F_q[x].");


/**
 * 2. Scrivere una funzione laterali(n,q), che calcola i laterali ciclotomici,
 * corrispondenti alle classi ciclotomiche delle radici n-esime dell'unità su
 * F_q.
 */

laterali(n, q, verbose=0) =
{
    /* Calling the function with a non-zero verbose parameter shows intermediate
     * steps: it does do some extra work than strictly needed and in exchange we
     * get the minimal complete set of representatives of cyclotomic cosets of q
     * modulo n (an optimization is possible for n = q^m - 1 for some m.)
     */

    my(                       \\ "c" for cosets and
        c1 = vector(n, i, -1) \\ "1" as aid to remember that vectors are 1-based
    );

    if( verbose, print("i -> cyclotomic cosets") );

    forstep( i = n-1, 0, -1,
        c1[ (i*q^0 % n) + 1 ] = i; \\ set the first element of the coset
        my(
            j = 1,
            iq0 = i*q^0 \\ just for readability
        );
        while( (i*q^j % n) != iq0,
            c1[ (i*q^j % n) + 1 ] = i;
            j++;
        );
        if( verbose, print(i, " -> ", c1) ); \\ show the intermediate steps
    );

    return( c1 );
}
addhelp(laterali, "laterali(n,q,{verbose=0}): a vector of length n whose (i+1)-th element is the number of the cyclotomic coset of which 0 ≤ i ≤ n-1 is a member.");

laterale(n, q, l) =
{
    /* powers, bitmask(…): helpers to create vecextract(…) bitmasks
     * coset(k): extracts the members of C_k from the vector laterali(n,q)
     */

    my(
        powers = vector(n, k, 2^(k-1)),
        bitmask(bits) = bits*powers~,

        cosets = laterali(n, q),

        representatives = vector(n, k, k-1),
        positions(k) = apply( ((x) -> x == k), cosets ),

        coset(k) = vecextract( representatives, bitmask( positions(k) ) ),

        i = cosets[ l + 1 ]
    );

    return( coset(i) );
}
addhelp(laterale, "laterale(n,q,l): the l-th cyclotomic coset of q modulo n (0 ≤ l ≤ n-1.)")


/**
 * 3. Scrivere una funzione irrnql(n,p,l) che, dati n,p,l con 0 ≤ l ≤ n-1,
 * calcola il fattore irriducibile di x^n - 1 in F_p[x] corrispondente all'unico
 * laterale ciclotomico a cui l appartiene.
 */

vecprod(v) =
{
    prod( i=1, #v, v[i] );
}
addhelp(vecprod, "vecprod(x): sum of the elements of the vector x.");

irrnql(n, p, l) =
{
    /* Find a suitable extension F_(p^h) such that
     * n divides the order of its multiplicative group.
     */

    my( h = 1 );
    while( (p^h - 1) % n, h++ );

    /* Pick a primitive n-th root of unity α to generate the whole F_(p^h).
     */

    my(
        f = primpoly(p, h, t),
        m = (p^h - 1) / n,
        alpha = Mod(t^m, f)
    );

    /* If M_l(x) is the minimal polynomial of α^l then
     *
     *     M_l(x) = \prod_{i in C_l} (x - α^i)
     *
     * where C_l is the unique cycolotomic coset containing l.
     */

    my(
        coset = laterale(n, p, l),
        factors = apply( ((i) -> x - alpha^i), coset )
    );
    return( vecprod( factors ) );
}
addhelp(irrnql, "irrnql(n,p,l): the irreducible factor over F_p[x] of x^n - 1 corresponding to the l-th cyclotomic coset of p modulo n.");


/**
 * 4. Scrivere una funzione circolgrorder(n,q) che restituisce l'ordine del
 * gruppo moltiplicativo di R_{n,q} = F_q[x] / ( x^n - 1 ).
 */

circolgrorder(n, q) =
{
    /* R a ring w/ 1, A_1,…,A_n pairwise coprime ideals
     * (i.e. i =/= j => (A_i) + (A_j) = R) then
     *
     *     R / ( A_1 ∩ … ∩ A_n )  ≃  (R / A_1) ⨯ … ⨯ (R / A_n)
     *
     * in particular for R = F_p[x] and A_i = (m_i(x))
     * where m_i runs through the irreducible factors of x^n - 1 over F_p[x]
     * i.e. i runs through a complete system of cyclotomic coset representatives
     * each factor of the product of rings is a field
     * and the number of invertibles of R_{n,q} is
     *
     *     \prod_{i} deg( m_i(x) ) - 1  =  \prod_{i} |C_i| - 1
     *
     * where C_i is the unique cyclotomic coset of q modulo n containing i
     */

    my(
        cosets = vecsort( laterali(n,q) ), \\ sort the system of representatives
        p = -1, \\ fake representative to skip 0
        t = 0   \\ accumulate (for each representative) sum of repetitions - 1
    );
    for( i=1, #cosets,
        if( cosets[i] == p, t++ );
        p = cosets[i];
    );
    return( t );
}
addhelp(circolgrorder, "circolgrorder(n,q): the order of the multiplicative group of the ring F_q[x] / (x^n - 1).")


/**
 * 5. Calcolare gli idempotenti minimali di R_{13,5}.
 */

foldr_( f, z, xs ) =
{
    my( x );
    if( #xs == 0,
        z,
        x = xs[1]; listpop( xs, 1 ); return( f( x, foldr_( f, z, xs ) ) );
    );
}

foldr(f, z, xs) = return( foldr_( f, z, List(xs) ) );

foldr1(f, xs) =
{
    my( x = xs[1] );
    xs = vecextract( xs, "2.." );
    return( foldr(f, x, xs) );
}

labels( n, q ) =
{
    my( l = 0, ls = List([l]), cosets = laterali( n, q ) );

    for( i = 1, #cosets,
        if( cosets[i] > l,
            l = cosets[i]; listput(ls, l),
        );
    );

    return( Vec(ls) );
}

rotations( xs ) = vector( #xs, i, rotate( xs, i ) );

rotate( xs, i ) =
{
    my(
        n = #xs,
        r = matrix( n, n, i, j, (i-1)-j % n == 0 )
    );
    return( ( r^i * xs~ )~ );
}

idempotent( xs, j ) =
{
    for( i = 1, #xs,
        xs[i] = Mod(i==j, xs[i]);
    );
    return( xs );
}

idempotents( n, q, prettyprint=0 ) =
{
    my(
        L = labels( n, q ),
        M = apply( (l) -> irrnql( n, q, l ), L ),
        Mr = rotations( M ),
        E = apply( (mr) -> idempotent(mr, 1), Mr ),
        RE = apply( (e) -> foldr1( chinese, e ), E )
    );
    if( prettyprint,
        Mat(lift(lift(lift(RE)))~),
        return( RE );
    );
}

esercizio5() = idempotents(13,5,1);


